# Nix node package repository

This is a collection of node packages expressed in the nix language. They can be installed via the nix package manager. They have been generated by [nixfromnpm](https://github.com/adnelson/nixfromnpm). The packages defined in this repo can be used as-is, for example as `buildInputs` or `propagatedBuildInputs` to other nix derivations, or can be used with `nixfromnpm` to auto-generate more nix expressions for other node packages. At present, the top 36 npm packages (as listed [here](https://www.npmjs.com/browse/star)) and all of their dependencies have been defined, though few of them tested.

## Using this library

Of course, make sure you have nix installed.

Clone the repo:

```bash
$ git clone https://github.com/adnelson/nix-node-packages.git
```

The expressions here refer to a `nixpkgs` path variable, so make sure you have it your `NIX_PATH`. For example, to point it at your `nixpkgs` channel:

```bash
$ export NIX_PATH="$HOME/.nix-defexpr/channels:$NIX_PATH"
```

After that you're free to do whatever you please with the library. Packages are located under the top-level attribute `nodePackages`. An unqualified name will build the latest version (as determined by comparing package version names), while a particular version can be referred to as shown below. For example, the following commands build the latest version of `grunt`, and version `0.4.5`, respectively:

```bash
$ nix-build nix-node-packages/nodePackages -A nodePackages.grunt
$ nix-build nix-node-packages/nodePackages -A nodePackages.grunt_0-4-5
```

## If a package doesn't build

There are any number of reasons why a package might not build. Some of the most common ones are:

* The `nixfromnpm` tool wasn't able to generate the definition of one of the package's dependencies. It will insert in the `brokenPackage` function, which, as might be anticipated, never builds. Looking at the call to `brokenPackage` will tell you why it couldn't build it. In my experience, this is because `nixfromnpm`'s version range checker is not completely up to spec, and it's unable to find a version that satisfies the bounds given by a `package.json`. If this is the case, the easiest way to fix it is to:
  * See what version range `nixfromnpm` failed to resolve. E.g. `foo@>=1.2.3-bar <2.3.4-baz.qux`.
  * Use `npm` to manually build the package at the given version bounds. E g. `npm install foo@>=1.2.3-bar <2.3.4-baz.qux`.
  * See what version it ends up building. E.g. `foo@1.2.3-xyz`.
  * Call `nixfromnpm` on that version. E.g. `nixfromnpm -o /path/to/nix-node-packages -p 'foo%1.2.3-xyz'`.
  * Replace the call to `brokenPackage` with `foo_1-2-3-xyz`.
* The build fails with `npm` complaining about HTTP errors. This is usually caused by a dependency that wasn't satified, likely because `nixfromnpm` calculated the wrong dependency. In this case, use steps similar to the above to find out what the actual dependency should be, and modify the package definition to include the correct one.
* A package build script is attempting to do some hacky bullshit like modifying its dependencies. This, of course, is not kosher in the `nix` view of things. In this case, you'll probably want to `nix-shell` into the package and see what it's trying to do. Figure out how to stop it from doing these things, and supply `prePatch` or `postPatch` steps to apply those changes.
* Circular dependencies (e.g. package A depends on package B which depends on package A). Fortunately this is relatively rare, but circular dependencies is something which npm supports. If there is a cycle in a dependency graph then nix will fail before building anything. The fix for this is described in the "How to Fix Circularity" section below.

Fixing broken packages is great, because the way nix works, you'll only need to fix them once (although, getting that to propagate to future versions might not be as easy). By all means, please make pull requests for any of these fixes.

## How to Fix Circularity

Here's how to fix packages which have circular dependencies. This process might become automated at some point, but for now it has to be done by hand.

1. Identify all of the packages which appear in the cycle. There might be more than one. Let's call this package list *C* for "cycle".
1. For *each* package in *C*, go into that package's nix definition and do the following:
  1. Remove any packages listed in that package's `deps` argument which appear in *C*. (There must be at least one, and possibly more than one).
  1. Make a variable pointing to a list of packages, which contains every package in *C* except for the package whose definition you are modifying. You can call this whatever you want, but in the example code below we call this `depClosure`.
  1. Add a `preConfigure` step which extracts the source tarballs of all of those packages and puts them in the `node_modules` folder, and then symlinks the current package directory into its own `node_modules` folder (required so that npm doesn't complain when checking dependencies).

Here's an example. We have the following dependency graph (`->` means "depends on"):

```
d -> es5-ext
es5-ext -> es6-iterator, es6-symbol
es6-iterator -> es5-ext, d, es6-symbol
es6-symbol -> es5-ext, d
```

As you can see we have cycles all over the place here. In this case, *C* is all four of the packages involved: `d`, `es5-ext`, `es6-iterator`, and `es6-symbol`. Let's look at how to modify the `d` package. The process is nearly identical for the other three. Here's the current definition:

```nix
{ buildNodePackage, nodePackages, pkgs }:
buildNodePackage {
  name = "d";
  version = "0.1.1";
  src = pkgs.fetchurl {
    url = "http://registry.npmjs.org/d/-/d-0.1.1.tgz";
    sha1 = "da184c535d18d8ee7ba2aa229b914009fae11309";
  };
  deps = with nodePackages; [
    es5-ext_0-10-11
  ];
}
```

First we remove the deps which appear in `C`. In this case, that just means removing all of the deps arguments:

```nix
{ buildNodePackage, nodePackages, pkgs }:
buildNodePackage {
  name = "d";
  version = "0.1.1";
  src = pkgs.fetchurl {
    url = "http://registry.npmjs.org/d/-/d-0.1.1.tgz";
    sha1 = "da184c535d18d8ee7ba2aa229b914009fae11309";
  };
}
```

Next, make a list containing the packages in *C* minus the package we're modifying:

```nix
{ buildNodePackage, nodePackages, pkgs }:

let
  depClosure = with nodePackages; [
    es5-ext_0-10-11
    es6-iterator_2-0-0
    es6-symbol_3-0-2
  ];
in

buildNodePackage {
  name = "d";
  version = "0.1.1";
  src = pkgs.fetchurl {
    url = "http://registry.npmjs.org/d/-/d-0.1.1.tgz";
    sha1 = "da184c535d18d8ee7ba2aa229b914009fae11309";
  };
}
```

Next, we add a `preConfigure` step which extracts these packages into `node_modules` and constructs a reflexive symlink, and a `postBuild` step which corrects the symlink at the end.

```nix
{ buildNodePackage, nodePackages, pkgs }:

let
  inherit (builtins) concatStringsSep;
  depClosure = with nodePackages; [
    es5-ext_0-10-11
    es6-iterator_2-0-0
    es6-symbol_3-0-2
  ];
  extractPkg = p: "tar xf ${p.src} && mv package node_modules/${p.fullName}";
in

buildNodePackage rec {
  name = "d";
  version = "0.1.1";
  src = pkgs.fetchurl {
    url = "http://registry.npmjs.org/d/-/d-0.1.1.tgz";
    sha1 = "da184c535d18d8ee7ba2aa229b914009fae11309";
  };
  preConfigure = concatStringsSep "\n" (
    ["mkdir -p node_modules"] ++
    map extractPkg depClosure ++
    ["ln -s $PWD node_modules/${name}"]
  );
  postBuild = ''
    rm node_modules/${name}
    ln -s $out/lib/node_modules/${name} node_modules/${name}
  '';
}
```

Now we're done; we can build `d` on its own without any circularity. All of the dependencies of its circular dependencies are satisfied because they all appear in the same `node_modules` folder.

## Extending the libraries

It's possible that you'll want to add additional packages that haven't been defined here. Alternatively, you might have your own packages, perhaps private, that you want to generate expressions for, but not have alongside all of the other packages in this repo. While you can always write these packages by hand, it's easier to do this with `nixfromnpm`. It can be obtained [here](https://github.com/adnelson/nixfromnpm). As with fixes above, feel free to pull request any new packages added, whether by hand or auto-generated.

### Adding new packages to the central package set

```bash
$ nixfromnpm -p package1 -p package2 -o nix-node-packages
```

This will calculate expressions for `package1` and `package2`, and place the generated expressions alongside all of the existing packages.

### Create a new package set which refers to the central set

```bash
$ nixfromnpm -p package1 -p package2 -o path/to/new/set --extend nix-node-packages
```

This will calculate expressions for `package1` and `package2`, and place them and their dependencies in `path/to/new/set`. However, any dependencies which exist in `nix-node-packages/nodePackages` will not need to be fetched, and will not appear in `path/to/new/set`.

### Generate a `default.nix` file from a project

You might have a project which has a `package.json` that specifies a bunch of dependencies. You can use `nixfromnpm` to generate expressions for the package's dependencies, and output a `default.nix` file for the package.

```bash
$ nixfromnpm -f path/to/project -o nix-node-packags
```
